
=== Internal Working of Git

TIP: It is recommended that you go through this section only if you have some experience with Git. Absolute beginners do not need to know this.

Let us explore some part of the internal working of Git through an example. I am using a Windows operating system and Git-Bash for this example.

Run `git init` to initialize an empty Git [repo] in the `inside_git` directory (root directory). An empty hidden directory `.git` is created in the root folder.

image::git-init.jpg[600, 600]

Using `du -c` we can list the sub-directories of the root directory `inside_git` and the size (in kbs) of each sub-directory. It shows the directories and the number of files inside them.

image::du-c-1.jpg[600, 600]

==== Blob object

Create a new file in the root folder.

image::touch-master_file_1.jpg[600, 600]

Now the root directory contains the `.git` directory and the new file `master_file_1.txt`.

image::ls-a-1.jpg[600, 600]

Let us add the file to the [staging area] using [`git add .`] and run `du -c` once again.

image::du-c-2.jpg[600, 600]

As you can see, a new directory `e6` has been added to `./.git/objects` and it contains one file. Let us use the `dir` (or `ls`) command to find out which file is present in the dir `./.git/objects/e6`.

image::dir-1.jpg[600, 600]

The file name `9de29bb2d1d6434b8b29ae775ad8c2e48c5391` has 38 characters. On combining it with the folder name (`e6`) at the start, it becomes a 40 character string `e69de29bb2d1d6434b8b29ae775ad8c2e48c5391`. This is a [SHA1] (Securing Hashing Algo 1) hash. Git encodes the content of the file (and more things, we'll get to that soon) in this hash. Every add and commit produces their own unique SHA1 hash(es). The first two characters of the hash are used for bucketing the hashes into folders by Git. The case of two hashes colliding is very rare. *Git uses 4 to 7 characters to refer to a commit in short.*

Now as mentioned in the previous paragraph, Git stores the contents of the file and other details in the hash. To check that out, we need to add some content to the file. The file will then have to be added again (this will produce another hash).

image::add-to-master_file_1-1.jpg[600, 600]
image::edit-master_file_1-1.jpg[600, 600]

From the last command in the above picture one can make out that a new hash `1a3851c172420a2198cf8ca6f2b776589d955cc5` was generated. Now let us check its contents using the `cat` command.

image::cat-1.jpg[600, 600]

Oops! That's gibberish! So was what was said above a lie? No. Git actually compresses files with https://www.zlib.net/[zlib] and then hashes them. So to make sense of the hash, we need to de-compress it.

image::de-compressed.jpg[600, 600]

`blob 16Git is amazing!` is what we get back.

Let us break that down:

* *`blob`* is the file type. It is an abbreviation for 'binary large object'. 
+
Files can be of three types in Git:

    ** blob
    ** commit
    ** tree

+
We will come to `commit` and `tree` soon.

* `16` is the file size. `Git is amazing!` consists of 15 characters, but Git adds a null character (`\0`) before the data, making the length 16.
* `Git is amazing!` is the file data that was originally entered.

NOTE: If `blob 16\0Git is amazing!` is hashed using SHA1, the same hash (`1a3851c172420a2198cf8ca6f2b776589d955cc5`) will be generated.

The process of finding the contents of the file using `cat` is pretty cumbersome. It is a better idea to use the [plumbing commands] provided by Git.

Some of the commands that we need:

* `git cat-file -p <hash>` (-p = pretty print) to display just the file data (contents).
* `git cat-file -t <hash>` (-t = type) to display just the file type (blob, commit or tree).
* `git cat-file -s <hash>` (-s = size) to display just the file size.

==== Commit and tree objects

Now let us commit the file using [`git commit`] and then run `du -c` again.

image::commit-master_file_1-1.jpg[600, 600]

From the above picture it can be noticed that two new directories `./.git/objects/1b` and `./.git/objects/d5` were created. Also, after commiting the file, Git gives us the first 7 characters of the SHA1 for that commit. Using the plumbing commands, let us first check the type of the file.

image::cat-file-t-1.jpg[600, 600]

So the type of the file is `commit`, telling us that this is a file generated through a commit.

Now let us check the content of the *commit file*.

image::cat-file-p-1.jpg[600, 600]

Let us break down the output:

* `tree 1b2190cdc2801ec3df6505dc351dee878ac7f2fc` is the SHA1 hash of the tree commit generated (remember that two files were generated in `./.git/objects` on committing the file). The tree is the [snapshot] of the current state of your local repository. We will look into the contents of the tree file soon.
* Parent commit SHA1 hash (not present here - we will do it soon.)
* The next line has the details of the author (the one who wrote the code):
    ** Name
    ** e-mail ID
    ** Timestamp
* The next line has the details of the committer (the one who pushed the code):
    ** Name
    ** e-mail ID
    ** Timestamp
* A blank line
* Commit message
* Commit description (if provided) (not present here)

Now let us check the contents of the *tree file*. (Take the hash from the commit file contents.)

image::cat-file-p-2.jpg[600, 600]

The tree file has entries of the files & directories in the current state of the repository, ie, the snapshot of the current state of the local repository.

The format of each line is the same. Let us have a look at `100644 blob 1a3851c172420a2198cf8ca6f2b776589d955cc5    master_file_1.txt`:

* `100644` mode
* `blob` is the file type (it can be of a tree type as well)
* `1a3851c172420a2198cf8ca6f2b776589d955cc5` is the latest SHA1 hash of the added file. It is the same as the hash generated while adding the file to the staging area. This hash can be of a file (ie, blob - like in this case) or a tree file.
* Name of the file.

let us take a look at the connections between the commit, tree and blob files.

image::connection-graph-1.png[600, 600]

==== Adding another file (parent commit)

Let us now create another file, add it to Git and commit it.

image::touch-master_file_2.jpg[600, 600]

Just like what was done before, let us check the contents of the commit file (using part of the hash `8282663` as seen in the above picture).

image::cat-file-p-3.jpg[600, 600]

A new line `parent d5b8f77ce1dc1a37b29885026055c8656c3e0b65`is seen. If you remember, then this is the hash of the previous commit. So Git is creating a graph. (We will have a look at the graph picture soon.) Also, the `HEAD` will now automatically point to this (latest) commit rather than the parent (previous) commit as it was doing before. To verify, let us have a look at where the `HEAD` is pointing.

image::head-1.jpg[600, 600]

Now let us check the contents of the tree of the latest commit.

image::cat-file-p-4.jpg[600, 600]

The new graph is as follows:

image::connection-graph-2.png[600, 600]

==== Creating a directory

Let us now create a new file (`master_dir_1_file_3.txt`) inside a a directory (`dir_1`), add it, commit it and look at the contents of the commit file.

image::mkdir_1.jpg[600, 600]

The commit file has the same format as before. Now let us have a look at the contents of the tree file (with SHA `f6a65` as seen in the above picture).

image::cat-file-p-5.jpg[600, 600]

It is surprising to note that the tree `f6a65` points to another tree `abecf`! The name of the new tree is `dir_1`. Now let us have a look at the contents of the `dir_1` tree.

image::cat-file-p-6.jpg[600, 600]

So it points to the file inside the directory `dir_1`.

Let us have a look at how the tree has connected itself to the blobs.

image::tree-1.png[600, 600]

Now let us have a look at the graph of the entire repository.

image::connection-graph-3.png[600, 600]

==== Renaming a file

Let us rename `master_file_1.txt` to `the_master_file.txt` and see how Git handles it internally.

image::mv-1.jpg[600, 600]

image::add-1.jpg[600, 600]

When the file is committed, Git is smart enough to recognize that a file has been renamed and is not a new file, as can be seen in the last line of the above picture.

Now let us check the contents of the commit and tree files.

image::cat-file-p-7.jpg[600, 600]

Take a look at the last line. The hash `1a385` is the same as master_file_1.txt (scroll up and check), just the name of the file has been changed in the tree object by Git instead of creating a new blob file. This is efficient space management by Git!

Let us take a look at the structure of the repo.

image::connection-graph-4.png[600, 600]

==== Making changes to huge files

Let us add and commit a picture to Git. The size of the picture is 1.374 Mb (or 1374 kb), so it is a relatively huge file as compared to the other files (~ 1 kb).

image::add-2.jpg[600, 600]

image::cat-file-p-8.jpg[600, 600]

Now let us make a small change to the png file contents (append a `.` to the file contents) and then add and commit it again.

image::add-3.jpg[600, 600]

On comparing the SHA1 hashes of `master_picture_1.png` in the latest (`6d2d2`) tree and the previous (`27666`) tree, we can make out that they are different. So Git has created two different blobs (`ca893` and `1f7af`) for the same file, even when they have a very small difference.

Let us run `du -c` now.

image::du-c-3.jpg[600, 600]

As we can see, there are two directories (`./.git/objects/1f` and `./.git/objects/ca`) with the same size (1376 kb).

NOTE: The directory content size (1376 kb) is greater than the picture size (1374 kb) as Git adds the file type and size to the blob file and then hashes it.

So is Git inefficient at handling huge files? No. The content of the file has changed and this produces a different SHA1 hash (`1f7af`) than the original SHA1 hash (`ca893`) and so Git is not able to identify the change. Having multiple copies of such a huge file is not a problem in the local storage, but it will take up a lot of bandwidth while [pushing] and [pulling] from a platform like [GitHub]. So to avoid this, Git uses Delta compression. It uses the difference ('diff.' in short) of the two files for the duplicate file and indicates the original as the parent. Let us look at this in the `Pack file` section below.

==== Pack file

*Delta compression* is carried out when the user pushes/pulls code to/from GitHub and when an aggressive garbage collection `git gc --aggressive` is carried out.

Delta compression creates two files in `./.git/objects/pack`:

* A pack file (.pack)
* An index file (.idx)

We will talk about them soon.

Let us view the current state of the repo.

image::du-c-3.jpg[600, 600]

Note the size of `./.git/objects/pack` in the above picture (0 kb).

We will be using an aggressive garbage collection to carry out delta compression and then view the changes.

image:du-c-4.jpg[600, 600]

Now the size of `./.git/objects/pack` in the above picture is 1380 kb and a lot of the files in `./.git/objects` have disappeared except for `./.git/objects/e6`. We will look at all of this one by one.

* Let us look at the contents of `./.git/objects/pack`.

+
image::dir-2.jpg[800, 800]
+
As mentioned above, two files (a pack file `.pack` and an index file `.idx`) are created.
+
Let us have a look at the contents of both the files using the plumbing command `git verify-pack -v path/to/pack/file/<file_name>.pack`. (Works with `.idx` as well.)
+
image::verify-pack-1.jpg[800, 800]
+
*The pack file is a single file containing the contents of all the objects that were removed from your file system.*
+
Have a look at the hash `1f7af` (the blob of the modified picture). Its size is very large as compared to the others. Now look the the hash `ca893` (the blob of the original picture). It is very small in size and it has the hash of the modified picture (`1f7af`) mentioned after it, indicating that its parent is the modified file. Thus, Git stored the diff for one of the files rather than the entire file twice, making it space efficient!

NOTE: A similar example can be found https://gist.github.com/matthewmccullough/2695758[here].

NOTE: The pack file has a graph in it, just like the commit, tree and blob files have one!

NOTE: The `.idx` (index) file stores the same content as the `.pack` file and is a file that *contains offsets into the pack file so you can quickly seek to a specific object*.

* Now let us talk about the `./.git/objects` directory.

+
On running the aggressive garbage collection, Git got rid of all the files that were related to commits and added them to the pack file. (On pushing and/or pulling, these files are not deleted, just a pack file and an index file are generated.)

* The `./.git/objects/e6` directory did not get removed as it was not related (connected) to any tree object.

PS: This has been learnt from https://www.youtube.com/watch?v=DjOk0jnqsLk[here].

'''